{"version":3,"sources":["Function.js"],"names":["Function","prototype","partial","args","fn","fn_id","next","global","partials","fn_string","toString","lhs_index","indexOf","rhs_index","all_names","slice","match","arg_names","filter","n","JSON","stringify","undefined","pow","Math","mul","floor","random"],"mappings":"AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;AAmBAA,SAASC,SAAT,CAAmBC,OAAnB,GAA6B,YAAqB;AAAA,QAAXC,IAAW,uEAAJ,EAAI;;AAC9C,QAAMC,KAAK,IAAX;AACA,QAAMC,QAAQC,MAAd;AACAC,WAAOC,QAAP,EAAiBH,KAAjB,IAA0BD,EAA1B;AACA,QAAMK,YAAYL,GAAGM,QAAH,EAAlB;AACA,QAAMC,YAAYF,UAAUG,OAAV,CAAkB,GAAlB,IAAyB,CAA3C;AACA,QAAMC,YAAYJ,UAAUG,OAAV,CAAkB,GAAlB,CAAlB;AACA,QAAME,YAAYL,UACbM,KADa,CACPJ,SADO,EACIE,SADJ,EACeG,KADf,CACqB,YADrB,CAAlB;AAEA,QAAMC,YAAYH,UACbI,MADa,CACN,UAACC,CAAD;AAAA,eAAOA,KAAKhB,IAAL,KAAc,KAArB;AAAA,KADM,CAAlB;AAEA,WAAOH,6CAAYiB,SAAZ,0DACiBG,KAAKC,SAAL,CAAeP,SAAf,CADjB,qCAEiBM,KAAKC,SAAL,CAAeJ,SAAf,CAFjB,8BAGUG,KAAKC,SAAL,CAAelB,IAAf,CAHV,uMAScK,QATd,cAS6BH,KAT7B,yEAAP;AAYH,CAvBD;AAwBA,IAAMG,0BAAwBF,MAA9B;AACA,IAAIC,OAAOC,QAAP,MAAqBc,SAAzB,EAAoC;AAChCf,WAAOC,QAAP,IAAmB,EAAnB;AACH;AACD,SAASF,IAAT,GAAgB;AACZ,QAAMiB,MAAMC,KAAKD,GAAL,CAAS,EAAT,EAAa,CAAb,CAAZ;AACA,QAAME,MAAM,KAAKF,GAAjB;AACA,WAAOC,KAAKE,KAAL,CAAWD,MAAMF,MAAMC,KAAKG,MAAL,EAAvB,EACFjB,QADE,CACO,EADP,EACWK,KADX,CACiB,CADjB,CAAP;AAEH","file":"Function.js","sourcesContent":["\"use strict\";\n/**\n * Allows  to  bind  *any* argument  using  their names  rather their\n * positions. This approach is more flexible if the initial arguments\n * are to be left unbound. For example, from the function `fn`\n * ```javascript\n * fn(arg_0, arg_1, .., arg_[n-3], arg_[n-2], arg_[n-1])\n * ```\n * we can create a new function `gn` which requires all arguments but\n * the last and the *third last* parameter by applying the\n * ```javascript\n * gn = fn.partial({arg_[n-3]: val_[n-3], arg_[n-1]: val_[n-1]})\n * ```\n * partial operation.  The invocation  of  `gn`  would be  like  `gn(\n * val_0, val_1, .., val_[n-2])`.  Notice that the relative positions\n * of the *unbound* arguments is left intact.\n *\n * @param args a map of named arguments\n * @returns a partially bound function\n */\nFunction.prototype.partial = function (args = {}) {\n    const fn = this;\n    const fn_id = next();\n    global[partials][fn_id] = fn;\n    const fn_string = fn.toString();\n    const lhs_index = fn_string.indexOf(\"(\") + 1;\n    const rhs_index = fn_string.indexOf(\")\");\n    const all_names = fn_string\n        .slice(lhs_index, rhs_index).match(/([^\\s,]+)/g);\n    const arg_names = all_names\n        .filter((n) => n in args === false);\n    return Function(...arg_names, `\"use strict\";\n        const all_names = ${JSON.stringify(all_names)};\n        const arg_names = ${JSON.stringify(arg_names)};\n        let args = ${JSON.stringify(args)};\n        for (const i in arguments) {\n            if (arguments.hasOwnProperty(i)) {\n                args[arg_names[i]] = arguments[i];\n            }\n        }\n        return global[\"${partials}\"][\"${fn_id}\"]\n            .apply(this, all_names.map(n => args[n]));\n    `);\n};\nconst partials = `_partials:${next()}`;\nif (global[partials] === undefined) {\n    global[partials] = {};\n}\nfunction next() {\n    const pow = Math.pow(36, 8);\n    const mul = 36 * pow;\n    return Math.floor(mul - pow * Math.random())\n        .toString(36).slice(1);\n}\n"]}