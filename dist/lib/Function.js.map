{"version":3,"sources":["Function.js"],"names":["Function","prototype","partial","args","id","random","fn","global","fn_string","toString","lhs_index","indexOf","rhs_index","all_names","slice","match","arg_names","filter","n","JSON","stringify","gid","Math","floor","key","value","g","undefined"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AAmBAA,SAASC,SAAT,CAAmBC,OAAnB,GAA6B,YAAqB;AAAA,QAAXC,IAAW,uEAAJ,EAAI;;AAC9C,QAAMC,KAAKC,QAAX;AACA,QAAMC,KAAKC,OAAOH,EAAP,EAAW,IAAX,CAAX;AACA,QAAMI,YAAYF,GAAGG,QAAH,EAAlB;AACA,QAAMC,YAAYF,UAAUG,OAAV,CAAkB,GAAlB,IAAyB,CAA3C;AACA,QAAMC,YAAYJ,UAAUG,OAAV,CAAkB,GAAlB,CAAlB;AACA,QAAME,YAAYL,UACbM,KADa,CACPJ,SADO,EACIE,SADJ,EACeG,KADf,CACqB,YADrB,CAAlB;AAEA,QAAMC,YAAYH,UACbI,MADa,CACN,UAACC,CAAD;AAAA,eAAOA,KAAKf,IAAL,KAAc,KAArB;AAAA,KADM,CAAlB;AAEA,WAAOH,6CAAYgB,SAAZ,0DACiBG,KAAKC,SAAL,CAAeP,SAAf,CADjB,qCAEiBM,KAAKC,SAAL,CAAeJ,SAAf,CAFjB,8BAGUG,KAAKC,SAAL,CAAejB,IAAf,CAHV,iNASwBkB,GATxB,cASkCjB,EATlC,yEAAP;AAYH,CAtBD;AAuBA,IAAMC,SAAS,SAATA,MAAS,GAAM;AACjB,WAAOiB,KAAKC,KAAL,CAAW,kBAAkB,gBAAgBD,KAAKjB,MAAL,EAA7C,EAA4DI,QAA5D,CAAqE,EAArE,EAAyEK,KAAzE,CAA+E,CAA/E,CAAP;AACH,CAFD;AAGA,IAAMP,SAAS,SAATA,MAAS,CAACiB,GAAD,EAAMC,KAAN,EAAgB;AAC3B,QAAMC,IAAI1B,SAAS,eAAT,GAAV;AACA,QAAI0B,iBAAeL,GAAf,MAA0BM,SAA9B,EAAyC;AACrCD,yBAAeL,GAAf,IAAwB,EAAxB;AACH;AACD,QAAII,UAAUE,SAAd,EAAyB;AACrBD,yBAAeL,GAAf,EAAsBG,GAAtB,IAA6BC,KAA7B;AACH;AACD,WAAOC,iBAAeL,GAAf,EAAsBG,GAAtB,CAAP;AACH,CATD;AAUA,IAAMH,MAAMhB,QAAZ","file":"Function.js","sourcesContent":["\"use strict\";\n/* tslint:disable:ban-types */\n/* tslint:disable:interface-name */\n/* tslint:disable:trailing-comma */\n/**\n * Allows  to  bind  *any* argument  using  their names  rather their\n * positions. This approach is more flexible if the initial arguments\n * are to be left unbound. For example, from the function `fn`\n * ```javascript\n * fn(arg_0, arg_1, .., arg_[n-3], arg_[n-2], arg_[n-1])\n * ```\n * we can create a new function `gn` which requires all arguments but\n * the last and the *third last* parameter by applying the\n * ```javascript\n * gn = fn.partial({arg_[n-3]: val_[n-3], arg_[n-1]: val_[n-1]})\n * ```\n * partial operation.  The invocation  of  `gn`  would be  like  `gn(\n * val_0, val_1, .., val_[n-2])`.  Notice that the relative positions\n * of the *unbound* arguments is left intact.\n *\n * @param args a map of named arguments\n * @returns a partially bound function\n */\nFunction.prototype.partial = function (args = {}) {\n    const id = random();\n    const fn = global(id, this);\n    const fn_string = fn.toString();\n    const lhs_index = fn_string.indexOf(\"(\") + 1;\n    const rhs_index = fn_string.indexOf(\")\");\n    const all_names = fn_string\n        .slice(lhs_index, rhs_index).match(/([^\\s,]+)/g);\n    const arg_names = all_names\n        .filter((n) => n in args === false);\n    return Function(...arg_names, `\"use strict\";\n        const all_names = ${JSON.stringify(all_names)};\n        const arg_names = ${JSON.stringify(arg_names)};\n        let args = ${JSON.stringify(args)};\n        for (const i in arguments) {\n            if (arguments.hasOwnProperty(i)) {\n                args[arg_names[i]] = arguments[i];\n            }\n        }\n        return global[\":partials-${gid}\"][\"${id}\"]\n            .apply(this, all_names.map(n => args[n]));\n    `);\n};\nconst random = () => {\n    return Math.floor(101559956668416 - 2821109907456 * Math.random()).toString(36).slice(1);\n};\nconst global = (key, value) => {\n    const g = Function(\"return global\")();\n    if (g[`:partials-${gid}`] === undefined) {\n        g[`:partials-${gid}`] = {};\n    }\n    if (value !== undefined) {\n        g[`:partials-${gid}`][key] = value;\n    }\n    return g[`:partials-${gid}`][key];\n};\nconst gid = random();\n"]}