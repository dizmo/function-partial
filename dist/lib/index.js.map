{"version":3,"sources":["index.js"],"names":["Object","defineProperty","exports","value","require","partial","fn","args","default"],"mappings":"AAAA;;AACAA,OAAOC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C,EAAEC,OAAO,IAAT,EAA7C;AACA;AACAC,QAAQ,YAAR;AACA;;;;;;;;;;;;;;;;AAgBA,SAASC,OAAT,CAAiBC,EAAjB,EAAqBC,IAArB,EAA2B;AACvB,SAAOD,GAAGD,OAAH,CAAWE,IAAX,CAAP;AACH;AACDL,QAAQG,OAAR,GAAkBA,OAAlB;AACAH,QAAQM,OAAR,GAAkBH,OAAlB","file":"index.js","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/* tslint:disable:ban-types interface-name */\nrequire(\"./Function\");\n/**\n * Allows  to  bind  *any* argument  using  their names  rather their\n * positions. This approach is more flexible if the initial arguments\n * are to be left unbound. For example, from the function `fn`\n * ```javascript\n * fn(arg_0, arg_1, .., arg_[n-3], arg_[n-2], arg_[n-1])\n * ```\n * we can create a new function `gn` which requires all arguments but\n * the last and the *third last* parameter by applying the\n * ```javascript\n * gn = partial(fn, {arg_[n-3]: val_[n-3], arg_[n-1]: val_[n-1]})\n * ```\n * partial operation.  The invocation  of  `gn`  would be  like  `gn(\n * val_0, val_1, .., val_[n-2])`.  Notice that the relative positions\n * of the *unbound* arguments is left intact.\n */\nfunction partial(fn, args) {\n    return fn.partial(args);\n}\nexports.partial = partial;\nexports.default = partial;\n"]}